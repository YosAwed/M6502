    // THEN キーワード
    {
        const char* txt = parser_ptr->text;
        uint16_t len = parser_ptr->length;
        uint16_t i = parser_ptr->position;
        bool found = false;
        while (i + 3 < len) {
            if (toupper((unsigned char)txt[i])=='T' && toupper((unsigned char)txt[i+1])=='H' &&
                toupper((unsigned char)txt[i+2])=='E' && toupper((unsigned char)txt[i+3])=='N') {
                bool left_ok = (i == 0) || !isalnum((unsigned char)txt[i-1]);
                bool right_ok = (i + 4 >= len) || !isalnum((unsigned char)txt[i+4]);
                if (left_ok && right_ok) { found = true; break; }
            }
            i++;
        }
        if (!found) {
            set_error(state, ERR_SYNTAX, "THEN expected in IF statement");
            return -1;
        }
        parser_ptr->position = i + 4;
        parser_ptr->current_char = (parser_ptr->position < parser_ptr->length) ? txt[parser_ptr->position] : '\0';
        while (parser_ptr->current_char == ' ' || parser_ptr->current_char == '\t') {
            parser_ptr->position++;
            parser_ptr->current_char = (parser_ptr->position < parser_ptr->length) ? txt[parser_ptr->position] : '\0';
        }
    }
    
    // 条件判定
    bool condition_true = false;
    if (condition.type == 0) { // 数値
        condition_true = (numeric_to_double(condition.value.num) != 0.0);
    } else { // 文字列
        condition_true = (condition.value.str.length > 0);
    }
    
    if (condition_true) {
        // 条件が真の場合、THEN以降を実行
        // 次のトークンが行番号かチェック
        token_t next_token = get_next_token(state, parser_ptr);
        if (next_token.type == TOKEN_NUMBER) {
            // GOTO文として処理
            uint16_t line_num = (uint16_t)numeric_to_double(next_token.value.number);
            return cmd_goto_line(state, line_num);
        } else {
            // 文として実行（実装簡略化のため、現在は未対応）
            set_error(state, ERR_UNDEF_STATEMENT, "Statement after THEN not implemented");
            return -1;
        }
    }
    
    return 0;
