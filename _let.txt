int cmd_let(basic_state_t* state, parser_state_t* parser) {
    token_t var_token = get_next_token(state, parser);
    
    if (var_token.type != TOKEN_VARIABLE) {
        set_error(state, ERR_SYNTAX, "Variable name expected");
        return -1;
    }
    
    token_t eq_token = get_next_token(state, parser);
    if (eq_token.type != TOKEN_OPERATOR || eq_token.value.operator != '=') {
        set_error(state, ERR_SYNTAX, "= expected");
        return -1;
    }
    
    token_t value_token = get_next_token(state, parser);
    
    // 変数作成または更新
    bool is_string = strchr(var_token.value.string, '$') != NULL;
    variable_type_t var_type = is_string ? VAR_STRING : VAR_NUMERIC;
    
    variable_t* var = create_variable(state, var_token.value.string, var_type);
    if (!var) return -1;
    
    if (is_string) {
        if (value_token.type != TOKEN_STRING) {
            set_error(state, ERR_TYPE_MISMATCH, NULL);
            return -1;
        }
        
        if (var->value.str.data) free(var->value.str.data);
        var->value.str.data = value_token.value.string;
        var->value.str.length = strlen(value_token.value.string);
    } else {
        if (value_token.type != TOKEN_NUMBER) {
            set_error(state, ERR_TYPE_MISMATCH, NULL);
            return -1;
        }
        
        var->value.num = value_token.value.number;
    }
    
    free(var_token.value.string);
    return 0;
}

// プログラム実行
int basic_run_program(basic_state_t* state) {
    if (!state) return -1;
    
    state->current_line = state->program_start;
    state->running = true;
    
    while (state->current_line && state->running && !has_error(state)) {
        program_line_t* before = state->current_line;
        int result = basic_execute_line(state, state->current_line->text);
        if (result != 0 || has_error(state) || !state->running) break;
        
        // If resuming mid-line (state->current_position set), or current_line changed, don't auto-advance
        if (state->current_line == before && state->current_position == 0) {
            state->current_line = state->current_line->next;
        }
    }
    
    state->running = false;
    return has_error(state) ? -1 : 0;
}


